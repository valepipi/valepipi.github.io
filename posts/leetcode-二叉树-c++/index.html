<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">


<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self'; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://www.google-analytics.com https://cdn.jsdelivr.net/; prefetch-src 'self'; connect-src 'self' https://www.google-analytics.com;">




<meta name="author" content="游泳小狗">
<meta name="description" content="本文为二叉树和二叉搜索树的Leetcode刷题记录。
参考资料: labuladong
🌴 &lt;二叉树&gt; 题目列表力扣题目 知识点 难度 104. 二叉树的最大深度 遍历 简单 543. 二叉树的直径 遍历 简单 144. 二叉树的前序遍历 遍历 简单 226. 翻转二叉树 遍历 简单 114. 二叉树展开为链表 递归 中等 116. 填充每个节点的下一个右侧节点指针 遍历三叉树 中等 105. 从前序与中序遍历序列构造二叉树 递归构造 中等 106. 从中序与后序遍历序列构造二叉树 递归构造 中等 889. 根据前序和后序遍历构造二叉树 递归构造(结果不唯一) 中等 654. 最大二叉树 递归构造 中等 652. 寻找重复的子树 后序遍历 中等 337. 打家劫舍 III 遍历 中等 236. 二叉树的最近公共祖先 递归 中等 222. 完全二叉树的节点个数 递归 中等 297. 二叉树的序列化与反序列化 递归 困难 题解二叉树结点定义">
<meta name="keywords" content="博客，个人">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="🌴 LeetCode二叉树题解 (C&#43;&#43;)"/>
<meta name="twitter:description" content="本文为二叉树和二叉搜索树的Leetcode刷题记录。
参考资料: labuladong
🌴 &lt;二叉树&gt; 题目列表力扣题目 知识点 难度 104. 二叉树的最大深度 遍历 简单 543. 二叉树的直径 遍历 简单 144. 二叉树的前序遍历 遍历 简单 226. 翻转二叉树 遍历 简单 114. 二叉树展开为链表 递归 中等 116. 填充每个节点的下一个右侧节点指针 遍历三叉树 中等 105. 从前序与中序遍历序列构造二叉树 递归构造 中等 106. 从中序与后序遍历序列构造二叉树 递归构造 中等 889. 根据前序和后序遍历构造二叉树 递归构造(结果不唯一) 中等 654. 最大二叉树 递归构造 中等 652. 寻找重复的子树 后序遍历 中等 337. 打家劫舍 III 遍历 中等 236. 二叉树的最近公共祖先 递归 中等 222. 完全二叉树的节点个数 递归 中等 297. 二叉树的序列化与反序列化 递归 困难 题解二叉树结点定义"/>

<meta property="og:title" content="🌴 LeetCode二叉树题解 (C&#43;&#43;)" />
<meta property="og:description" content="本文为二叉树和二叉搜索树的Leetcode刷题记录。
参考资料: labuladong
🌴 &lt;二叉树&gt; 题目列表力扣题目 知识点 难度 104. 二叉树的最大深度 遍历 简单 543. 二叉树的直径 遍历 简单 144. 二叉树的前序遍历 遍历 简单 226. 翻转二叉树 遍历 简单 114. 二叉树展开为链表 递归 中等 116. 填充每个节点的下一个右侧节点指针 遍历三叉树 中等 105. 从前序与中序遍历序列构造二叉树 递归构造 中等 106. 从中序与后序遍历序列构造二叉树 递归构造 中等 889. 根据前序和后序遍历构造二叉树 递归构造(结果不唯一) 中等 654. 最大二叉树 递归构造 中等 652. 寻找重复的子树 后序遍历 中等 337. 打家劫舍 III 遍历 中等 236. 二叉树的最近公共祖先 递归 中等 222. 完全二叉树的节点个数 递归 中等 297. 二叉树的序列化与反序列化 递归 困难 题解二叉树结点定义" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://valepipi.github.io/posts/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-c&#43;&#43;/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-07T14:26:59+08:00" />
<meta property="article:modified_time" content="2023-05-07T14:26:59+08:00" /><meta property="og:site_name" content="游泳小狗" />




  <title>游泳小狗</title>

  
  <link rel="canonical" href="https://valepipi.github.io/posts/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-c&#43;&#43;/">
  

  <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css" integrity="sha256-axpPvEiVW3Kup5E&#43;Q/q&#43;tF6LwSDaWqQbWY3TOtysS1k=" crossorigin="anonymous" media="screen" />





  
  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css" integrity="sha256-OeQafxa9&#43;MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin="anonymous" media="screen" />
  



   




  <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">


  

  <meta name="generator" content="Hugo 0.101.0" />


  

</head>







<body class="preload-transitions colorscheme-dark">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      游泳小狗
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于我</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">博客</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/projects/">爱好</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/contact/">联系我</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://valepipi.github.io/en/posts/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-c&#43;&#43;/">英文</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://valepipi.github.io/posts/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-c&#43;&#43;/">
              🌴 LeetCode二叉树题解 (C&#43;&#43;)
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2023-05-07T14:26:59&#43;08:00">
                May 7, 2023
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              阅读时间：9 分钟
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/blog/">blog</a></div>

          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/leetcode/">LeetCode</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <p>本文为二叉树和二叉搜索树的Leetcode刷题记录。</p>
<blockquote>
<p>参考资料: <a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-8f403/">labuladong</a></p>
</blockquote>
<h1 id="-二叉树--题目列表">
  🌴 &lt;二叉树&gt;  题目列表
  <a class="heading-link" href="#-%e4%ba%8c%e5%8f%89%e6%a0%91--%e9%a2%98%e7%9b%ae%e5%88%97%e8%a1%a8">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<table>
<thead>
<tr>
<th>力扣题目</th>
<th>知识点</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></td>
<td>遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td>
<td>遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></td>
<td>遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></td>
<td>遍历</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td>
<td>递归</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></td>
<td>遍历三叉树</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></td>
<td>递归构造</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></td>
<td>递归构造</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></td>
<td>递归构造(结果不唯一)</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></td>
<td>递归构造</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></td>
<td>后序遍历</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/house-robber-iii/?favorite=59jEaTgw">337. 打家劫舍 III</a></td>
<td>遍历</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></td>
<td>递归</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></td>
<td>递归</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/?favorite=59jEaTgw">297. 二叉树的序列化与反序列化</a></td>
<td>递归</td>
<td>困难</td>
</tr>
</tbody>
</table>
<h1 id="题解">
  题解
  <a class="heading-link" href="#%e9%a2%98%e8%a7%a3">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<p><strong>二叉树结点定义</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>  Definition <span style="font-weight:bold">for</span> a binary tree node.
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">struct</span> <span style="font-weight:bold">TreeNode</span> {
</span></span><span style="display:flex;"><span>      <span style="">int</span> val;
</span></span><span style="display:flex;"><span>      TreeNode *left;
</span></span><span style="display:flex;"><span>      TreeNode *right;
</span></span><span style="display:flex;"><span>      TreeNode() : val(0), left(<span style="font-weight:bold">nullptr</span>), right(<span style="font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>      TreeNode(<span style="">int</span> x) : val(x), left(<span style="font-weight:bold">nullptr</span>), right(<span style="font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>      TreeNode(<span style="">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>  };
</span></span></code></pre></div><h2 id="104-二叉树的最大深度httpsleetcodecnproblemsmaximum-depth-of-binary-tree">
  <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>
  <a class="heading-link" href="#104-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6httpsleetcodecnproblemsmaximum-depth-of-binary-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>法1：直接递归</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">int</span> maxDepth(TreeNode* root) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> 0;
</span></span><span style="display:flex;"><span>        <span style="">int</span> left = maxDepth(root-&gt;left);
</span></span><span style="display:flex;"><span>        <span style="">int</span> right = maxDepth(root-&gt;right);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> 1 + max(left, right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>法2：回溯法+前序遍历，单独递归遍历，遍历中更新全局变量</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">int</span> res = 0;
</span></span><span style="display:flex;"><span>    <span style="">int</span> depth = 0;
</span></span><span style="display:flex;"><span>    <span style="">int</span> maxDepth(TreeNode* root) {
</span></span><span style="display:flex;"><span>        traverse(root);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">void</span> traverse(TreeNode* root){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        depth++;
</span></span><span style="display:flex;"><span>        res = max(depth, res);
</span></span><span style="display:flex;"><span>        traverse(root-&gt;left);
</span></span><span style="display:flex;"><span>        traverse(root-&gt;right);
</span></span><span style="display:flex;"><span>        depth--;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="543-二叉树的直径httpsleetcodecnproblemsdiameter-of-binary-tree">
  <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a>
  <a class="heading-link" href="#543-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84httpsleetcodecnproblemsdiameter-of-binary-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>后序遍历，利用返回信息，单独递归，后序位置更新全局变量</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="">int</span> res = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">int</span> diameterOfBinaryTree(TreeNode* root) {
</span></span><span style="display:flex;"><span>        traverse(root);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">int</span> traverse(TreeNode* root){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> 0;
</span></span><span style="display:flex;"><span>        <span style="">int</span> left = traverse(root-&gt;left);
</span></span><span style="display:flex;"><span>        <span style="">int</span> right = traverse(root-&gt;right);
</span></span><span style="display:flex;"><span>        res = max(res, left+right);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> 1 + max(left, right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="144-二叉树的前序遍历httpsleetcodecnproblemsbinary-tree-preorder-traversal">
  <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>
  <a class="heading-link" href="#144-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%89%8d%e5%ba%8f%e9%81%8d%e5%8e%86httpsleetcodecnproblemsbinary-tree-preorder-traversal">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>单独递归</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    vector&lt;<span style="">int</span>&gt; res;
</span></span><span style="display:flex;"><span>    vector&lt;<span style="">int</span>&gt; preorderTraversal(TreeNode* root) {
</span></span><span style="display:flex;"><span>        traverse(root);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">void</span> traverse(TreeNode* root){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        res.push_back(root-&gt;val);
</span></span><span style="display:flex;"><span>        traverse(root-&gt;left);
</span></span><span style="display:flex;"><span>        traverse(root-&gt;right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="226-翻转二叉树httpsleetcodecnproblemsinvert-binary-tree">
  <a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a>
  <a class="heading-link" href="#226-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsinvert-binary-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>法1：直接递归</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* invertTree(TreeNode* root) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        TreeNode* left = invertTree(root-&gt;left);
</span></span><span style="display:flex;"><span>        TreeNode* right = invertTree(root-&gt;right);
</span></span><span style="display:flex;"><span>        root-&gt;left = right;
</span></span><span style="display:flex;"><span>        root-&gt;right = left;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>法2：单独递归</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* invertTree(TreeNode* root) {
</span></span><span style="display:flex;"><span>        traverse(root);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">void</span> traverse(TreeNode* root){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        TreeNode* tmp = root-&gt;left;
</span></span><span style="display:flex;"><span>        root-&gt;left = root-&gt;right;
</span></span><span style="display:flex;"><span>        root-&gt;right = tmp;
</span></span><span style="display:flex;"><span>        traverse(root-&gt;left);
</span></span><span style="display:flex;"><span>        traverse(root-&gt;right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="114-二叉树展开为链表httpsleetcodecnproblemsflatten-binary-tree-to-linked-list">
  <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a>
  <a class="heading-link" href="#114-%e4%ba%8c%e5%8f%89%e6%a0%91%e5%b1%95%e5%bc%80%e4%b8%ba%e9%93%be%e8%a1%a8httpsleetcodecnproblemsflatten-binary-tree-to-linked-list">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>以先序结果展开为链表<br>
递归，在后序位置，利用左右子树递归结果</p>
<ol>
<li>展开左右子树</li>
<li>处理根节点：<br>
左子树置为Null<br>
右子树上接原来的左子树<br>
右子树末端接原来的右子树</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">void</span> flatten(TreeNode* root) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        flatten(root-&gt;left);
</span></span><span style="display:flex;"><span>        flatten(root-&gt;right);
</span></span><span style="display:flex;"><span>        TreeNode* left = root-&gt;left;
</span></span><span style="display:flex;"><span>        TreeNode* right = root-&gt;right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root-&gt;left = <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        root-&gt;right = left;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        TreeNode* p = root;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">while</span>(p-&gt;right != <span style="font-weight:bold">nullptr</span>) p = p-&gt;right;
</span></span><span style="display:flex;"><span>        p-&gt;right = right;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="116-填充每个节点的下一个右侧节点指针httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node">
  <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a>
  <a class="heading-link" href="#116-%e5%a1%ab%e5%85%85%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e5%8f%b3%e4%be%a7%e8%8a%82%e7%82%b9%e6%8c%87%e9%92%88httpsleetcodecnproblemspopulating-next-right-pointers-in-each-node">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>伪三叉树结点定义</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Node</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">int</span> val;
</span></span><span style="display:flex;"><span>    Node* left;
</span></span><span style="display:flex;"><span>    Node* right;
</span></span><span style="display:flex;"><span>    Node* next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node() : val(0), left(NULL), right(NULL), next(NULL) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node(<span style="">int</span> _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node(<span style="">int</span> _val, Node* _left, Node* _right, Node* _next)
</span></span><span style="display:flex;"><span>        : val(_val), left(_left), right(_right), next(_next) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>三叉树单独递归遍历，扩展参数列表</p>
<ol>
<li>前序位置，处理当前结点：连接左右子树</li>
<li>递归处理左子树：连接它的左右子树</li>
<li>递归处理右子树：连接它的左右子树</li>
<li>递归连接左右子树：左子树的右边-&gt;右子树的左边</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    Node* connect(Node* root) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        traverse(root-&gt;left, root-&gt;right);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">void</span> traverse(Node* node1, Node* node2){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(node1 == <span style="font-weight:bold">nullptr</span> || node2 == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        node1-&gt;next = node2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        traverse(node1-&gt;left, node1-&gt;right);
</span></span><span style="display:flex;"><span>        traverse(node2-&gt;left, node2-&gt;right);
</span></span><span style="display:flex;"><span>        traverse(node1-&gt;right, node2-&gt;left); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="105-从前序与中序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal">
  <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>
  <a class="heading-link" href="#105-%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-inorder-traversal">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span>    unordered_map&lt;<span style="">int</span>, <span style="">int</span>&gt; val2index;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* buildTree(vector&lt;<span style="">int</span>&gt;&amp; preorder, vector&lt;<span style="">int</span>&gt;&amp; inorder) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i &lt; inorder.size(); i++)
</span></span><span style="display:flex;"><span>            val2index[inorder[i]] = i;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeNode* build(vector&lt;<span style="">int</span>&gt;&amp; preorder, <span style="">int</span> preStart, <span style="">int</span> preEnd, vector&lt;<span style="">int</span>&gt;&amp; inorder, <span style="">int</span> inStart, <span style="">int</span> inEnd){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(preEnd&lt;preStart) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="">int</span> rootVal = preorder[preStart];
</span></span><span style="display:flex;"><span>        <span style="">int</span> index = val2index[rootVal];
</span></span><span style="display:flex;"><span>        TreeNode* root = <span style="font-weight:bold">new</span> TreeNode(rootVal);
</span></span><span style="display:flex;"><span>        <span style="">int</span> leftsize = index - inStart;
</span></span><span style="display:flex;"><span>        root-&gt;left = build(preorder, preStart+1, preStart+leftsize, inorder, inStart, index-1);
</span></span><span style="display:flex;"><span>        root-&gt;right = build(preorder, preStart+leftsize+1, preEnd, inorder, index+1, inEnd);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="106-从中序与后序遍历序列构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal">
  <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a>
  <a class="heading-link" href="#106-%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-inorder-and-postorder-traversal">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span>    unordered_map&lt;<span style="">int</span>, <span style="">int</span>&gt; val2index;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* buildTree(vector&lt;<span style="">int</span>&gt;&amp; inorder, vector&lt;<span style="">int</span>&gt;&amp; postorder) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i &lt; inorder.size(); i++){
</span></span><span style="display:flex;"><span>            val2index[inorder[i]] = i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> build(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeNode* build(vector&lt;<span style="">int</span>&gt;&amp; inorder, <span style="">int</span> inStart, <span style="">int</span> inEnd, vector&lt;<span style="">int</span>&gt;&amp; postorder, <span style="">int</span> postStart, <span style="">int</span> postEnd){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(inStart&gt;inEnd) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="">int</span> rootVal = postorder[postEnd];
</span></span><span style="display:flex;"><span>        <span style="">int</span> index = val2index[rootVal];
</span></span><span style="display:flex;"><span>        TreeNode* root = <span style="font-weight:bold">new</span> TreeNode(rootVal);
</span></span><span style="display:flex;"><span>        <span style="">int</span> leftsize = index - inStart;
</span></span><span style="display:flex;"><span>        root-&gt;left = build(inorder, inStart, index-1, postorder, postStart, postStart+leftsize-1);
</span></span><span style="display:flex;"><span>        root-&gt;right = build(inorder, index+1, inEnd, postorder, postStart+leftsize, postEnd-1);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="889-根据前序和后序遍历构造二叉树httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal">
  <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a>
  <a class="heading-link" href="#889-%e6%a0%b9%e6%8d%ae%e5%89%8d%e5%ba%8f%e5%92%8c%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsconstruct-binary-tree-from-preorder-and-postorder-traversal">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>    unordered_map&lt;<span style="">int</span>, <span style="">int</span>&gt; val2index;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* constructFromPrePost(vector&lt;<span style="">int</span>&gt;&amp; preorder, vector&lt;<span style="">int</span>&gt;&amp; postorder) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i&lt;postorder.size();i++){
</span></span><span style="display:flex;"><span>            val2index[postorder[i]] = i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> build(
</span></span><span style="display:flex;"><span>            preorder, 0, preorder.size()-1,\
</span></span><span style="display:flex;"><span>            postorder, 0, postorder.size()-1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeNode* build(
</span></span><span style="display:flex;"><span>    vector&lt;<span style="">int</span>&gt;&amp; preorder,
</span></span><span style="display:flex;"><span>    <span style="">int</span> preStart,
</span></span><span style="display:flex;"><span>    <span style="">int</span> preEnd,
</span></span><span style="display:flex;"><span>    vector&lt;<span style="">int</span>&gt;&amp; postorder,
</span></span><span style="display:flex;"><span>    <span style="">int</span> postStart,
</span></span><span style="display:flex;"><span>    <span style="">int</span> postEnd
</span></span><span style="display:flex;"><span>){
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span>(preStart&gt;preEnd) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span>(preStart == preEnd) <span style="font-weight:bold">return</span> <span style="font-weight:bold">new</span> TreeNode(preorder[preStart]);
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">//构造根节点
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>    <span style="">int</span> rootVal = preorder[preStart];
</span></span><span style="display:flex;"><span>    TreeNode* root = <span style="font-weight:bold">new</span> TreeNode(rootVal);
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">//左子树的根节点
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>    <span style="">int</span> leftrootVal = preorder[preStart+1];
</span></span><span style="display:flex;"><span>    <span style="">int</span> index = val2index[leftrootVal];
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">//构造左右子树
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>    <span style="">int</span> leftsize = index - postStart + 1;
</span></span><span style="display:flex;"><span>    root-&gt;left = build(preorder, preStart+1, preStart+leftsize, postorder, postStart, index);
</span></span><span style="display:flex;"><span>    root-&gt;right = build(preorder, preStart+leftsize+1, preEnd, postorder, index+1, postEnd-1);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="654-最大二叉树httpsleetcodecnproblemsmaximum-binary-tree">
  <a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a>
  <a class="heading-link" href="#654-%e6%9c%80%e5%a4%a7%e4%ba%8c%e5%8f%89%e6%a0%91httpsleetcodecnproblemsmaximum-binary-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* constructMaximumBinaryTree(vector&lt;<span style="">int</span>&gt;&amp; nums) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> build(nums, 0, nums.size()-1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeNode* build(vector&lt;<span style="">int</span>&gt;&amp; nums, <span style="">int</span> lo, <span style="">int</span> hi){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (lo &gt; hi) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">//找最大值
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        <span style="">int</span> index = -1;
</span></span><span style="display:flex;"><span>        <span style="">int</span> maxVal = INT_MIN;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">int</span> i = lo; i &lt;= hi; i++){
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span>(maxVal &lt; nums[i]){
</span></span><span style="display:flex;"><span>                index = i;
</span></span><span style="display:flex;"><span>                maxVal = nums[i];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">//递归构建
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        TreeNode* root = <span style="font-weight:bold">new</span> TreeNode(maxVal);
</span></span><span style="display:flex;"><span>        root-&gt;left = build(nums, lo, index-1);
</span></span><span style="display:flex;"><span>        root-&gt;right = build(nums, index+1, hi);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="652-寻找重复的子树httpsleetcodecnproblemsfind-duplicate-subtrees">
  <a href="https://leetcode.cn/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a>
  <a class="heading-link" href="#652-%e5%af%bb%e6%89%be%e9%87%8d%e5%a4%8d%e7%9a%84%e5%ad%90%e6%a0%91httpsleetcodecnproblemsfind-duplicate-subtrees">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>利用前序结果的字符串唯一标记该子树<br>
memo备忘录记录出现次数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    unordered_map&lt;string, <span style="">int</span>&gt; memo;
</span></span><span style="display:flex;"><span>    vector&lt;TreeNode*&gt; res;
</span></span><span style="display:flex;"><span>    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) {
</span></span><span style="display:flex;"><span>        traverse(root);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    string traverse(TreeNode* root){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> <span style="font-style:italic">&#34;#&#34;</span>;
</span></span><span style="display:flex;"><span>        string left = traverse(root-&gt;left);
</span></span><span style="display:flex;"><span>        string right = traverse(root-&gt;right);
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">//利用前序结果唯一标记该子树
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        string cur = to_string(root-&gt;val) + <span style="font-style:italic">&#34;,&#34;</span> + left +  <span style="font-style:italic">&#34;,&#34;</span> + right;
</span></span><span style="display:flex;"><span>        <span style="">int</span> freq= memo[cur];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(freq == 1) res.push_back(root);
</span></span><span style="display:flex;"><span>        memo[cur] = freq + 1;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> cur;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="337-打家劫舍-iiihttpsleetcodecnproblemshouse-robber-iiifavorite59jeatgw">
  <a href="https://leetcode.cn/problems/house-robber-iii/?favorite=59jEaTgw">337. 打家劫舍 III</a>
  <a class="heading-link" href="#337-%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8d-iiihttpsleetcodecnproblemshouse-robber-iiifavorite59jeatgw">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    unordered_map&lt;TreeNode*, <span style="">int</span>&gt; memo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="">int</span> rob(TreeNode* root) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> 0;
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">// 利用备忘录消除重叠子问题
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        <span style="font-weight:bold">if</span> (memo.count(root))
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> memo[root];
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">// 抢，然后去下下家
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        <span style="">int</span> do_it = root-&gt;val
</span></span><span style="display:flex;"><span>                    + (root-&gt;left == <span style="font-weight:bold">nullptr</span> ?
</span></span><span style="display:flex;"><span>                       0 : rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right))
</span></span><span style="display:flex;"><span>                    + (root-&gt;right == <span style="font-weight:bold">nullptr</span> ?
</span></span><span style="display:flex;"><span>                       0 : rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right));
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">// 不抢，然后去下家
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        <span style="">int</span> not_do = rob(root-&gt;left) + rob(root-&gt;right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="">int</span> res = max(do_it, not_do);
</span></span><span style="display:flex;"><span>        memo[root] = res;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="236-二叉树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree">
  <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>
  <a class="heading-link" href="#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == NULL) <span style="font-weight:bold">return</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(p == root || q == root) <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
</span></span><span style="display:flex;"><span>        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(left != NULL &amp;&amp; right != NULL) <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(left == NULL &amp;&amp; right == NULL) <span style="font-weight:bold">return</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> left == NULL ? right: left;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="222-完全二叉树的节点个数httpsleetcodecnproblemscount-complete-tree-nodes">
  <a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a>
  <a class="heading-link" href="#222-%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%aa%e6%95%b0httpsleetcodecnproblemscount-complete-tree-nodes">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == NULL) <span style="font-weight:bold">return</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(p == root || q == root) <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
</span></span><span style="display:flex;"><span>        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(left != NULL &amp;&amp; right != NULL) <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(left == NULL &amp;&amp; right == NULL) <span style="font-weight:bold">return</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> left == NULL ? right: left;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="297-二叉树的序列化与反序列化httpsleetcodecnproblemsserialize-and-deserialize-binary-treefavorite59jeatgw">
  <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/?favorite=59jEaTgw">297. 二叉树的序列化与反序列化</a>
  <a class="heading-link" href="#297-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e4%b8%8e%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96httpsleetcodecnproblemsserialize-and-deserialize-binary-treefavorite59jeatgw">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Codec</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">char</span> SEP = <span style="font-style:italic">&#39;,&#39;</span>;
</span></span><span style="display:flex;"><span>    string NULL_PTR = <span style="font-style:italic">&#34;#&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">// Encodes a tree to a single string.
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>    string serialize(TreeNode* root) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> (root == NULL) <span style="font-weight:bold">return</span> NULL_PTR + SEP;
</span></span><span style="display:flex;"><span>        string res = to_string(root-&gt;val) + SEP;
</span></span><span style="display:flex;"><span>        res += serialize(root-&gt;left);
</span></span><span style="display:flex;"><span>        res += serialize(root-&gt;right);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">// Decodes your encoded data to tree.
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>    TreeNode* deserialize(string data) {
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">//string data to queue&lt;string&gt; nodes数组
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        queue&lt;string&gt; nodes;
</span></span><span style="display:flex;"><span>        string cur = <span style="font-style:italic">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">char</span> ch: data){
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span>(ch == SEP){
</span></span><span style="display:flex;"><span>                nodes.push(cur);
</span></span><span style="display:flex;"><span>                cur = <span style="font-style:italic">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>            }<span style="font-weight:bold">else</span>{
</span></span><span style="display:flex;"><span>                cur += ch;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">//decode每个node
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        <span style="font-weight:bold">return</span> decode(nodes);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeNode* decode(queue&lt;string&gt;&amp; nodes){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(nodes.empty()) <span style="font-weight:bold">return</span> NULL;
</span></span><span style="display:flex;"><span>        string rootVal = nodes.front();
</span></span><span style="display:flex;"><span>        nodes.pop();
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(rootVal == NULL_PTR) <span style="font-weight:bold">return</span> NULL;
</span></span><span style="display:flex;"><span>        TreeNode* root = <span style="font-weight:bold">new</span> TreeNode(stoi(rootVal));
</span></span><span style="display:flex;"><span>        root-&gt;left = decode(nodes);
</span></span><span style="display:flex;"><span>        root-&gt;right = decode(nodes);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="-二叉搜索树bst--题目列表">
  🌴 &lt;二叉搜索树BST&gt;  题目列表
  <a class="heading-link" href="#-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91bst--%e9%a2%98%e7%9b%ae%e5%88%97%e8%a1%a8">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<table>
<thead>
<tr>
<th>力扣题目</th>
<th>知识点</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></td>
<td>中序遍历</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></td>
<td>中序遍历</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td>
<td>递归</td>
<td>简单</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></td>
<td>递归</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></td>
<td>递归</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></td>
<td>递归(分解)</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td>
<td>后序递归+备忘录</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></td>
<td>后序递归构造+穷举</td>
<td>中等</td>
</tr>
<tr>
<td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></td>
<td></td>
<td>中等</td>
</tr>
</tbody>
</table>
<h1 id="题解-1">
  题解
  <a class="heading-link" href="#%e9%a2%98%e8%a7%a3-1">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<h2 id="538-把二叉搜索树转换为累加树httpsleetcodecnproblemsconvert-bst-to-greater-tree">
  <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>
  <a class="heading-link" href="#538-%e6%8a%8a%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%b4%af%e5%8a%a0%e6%a0%91httpsleetcodecnproblemsconvert-bst-to-greater-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="">int</span> sum = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* convertBST(TreeNode* root) {
</span></span><span style="display:flex;"><span>        traverse(root);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">void</span> traverse(TreeNode* root){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(!root) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        traverse(root-&gt;right);
</span></span><span style="display:flex;"><span>        sum += root-&gt;val;
</span></span><span style="display:flex;"><span>        root-&gt;val = sum;
</span></span><span style="display:flex;"><span>        traverse(root-&gt;left);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="230-二叉搜索树中第k小的元素httpsleetcodecnproblemskth-smallest-element-in-a-bst">
  <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a>
  <a class="heading-link" href="#230-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%ac%ack%e5%b0%8f%e7%9a%84%e5%85%83%e7%b4%a0httpsleetcodecnproblemskth-smallest-element-in-a-bst">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="">int</span> rank = 0;
</span></span><span style="display:flex;"><span>    <span style="">int</span> res = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">int</span> kthSmallest(TreeNode* root, <span style="">int</span> k) {
</span></span><span style="display:flex;"><span>        traverse(root, k, rank, res);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">void</span> traverse(TreeNode* root, <span style="">int</span> k, <span style="">int</span>&amp; rank, <span style="">int</span>&amp; res){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        traverse(root-&gt;left, k, rank, res);
</span></span><span style="display:flex;"><span>        rank++;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(rank == k){
</span></span><span style="display:flex;"><span>            res = root-&gt;val;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        traverse(root-&gt;right, k, rank, res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="700-二叉搜索树中的搜索httpsleetcodecnproblemssearch-in-a-binary-search-tree">
  <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a>
  <a class="heading-link" href="#700-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%90%9c%e7%b4%a2httpsleetcodecnproblemssearch-in-a-binary-search-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* searchBST(TreeNode* root, <span style="">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(val &lt; root-&gt;val) <span style="font-weight:bold">return</span> searchBST(root-&gt;left, val);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(val &gt; root-&gt;val) <span style="font-weight:bold">return</span> searchBST(root-&gt;right, val);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="98-验证二叉搜索树httpsleetcodecnproblemsvalidate-binary-search-tree">
  <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>
  <a class="heading-link" href="#98-%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcodecnproblemsvalidate-binary-search-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">bool</span> isValidBST(TreeNode* root) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> isValid(root, <span style="font-weight:bold">nullptr</span>, <span style="font-weight:bold">nullptr</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">bool</span> isValid(TreeNode* root, TreeNode* min, TreeNode* max){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(!root) <span style="font-weight:bold">return</span> true;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(min != <span style="font-weight:bold">nullptr</span> &amp;&amp; root-&gt;val &lt;= min-&gt;val) <span style="font-weight:bold">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(max != <span style="font-weight:bold">nullptr</span> &amp;&amp; root-&gt;val &gt;= max-&gt;val) <span style="font-weight:bold">return</span> false;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> isValid(root-&gt;left, min, root) &amp;&amp; isValid(root-&gt;right, root, max);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="701-二叉搜索树中的插入操作httpsleetcodecnproblemsinsert-into-a-binary-search-tree">
  <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a>
  <a class="heading-link" href="#701-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9chttpsleetcodecnproblemsinsert-into-a-binary-search-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* insertIntoBST(TreeNode* root, <span style="">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> <span style="font-weight:bold">new</span> TreeNode(val);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(val &lt; root-&gt;val) root-&gt;left = insertIntoBST(root-&gt;left, val);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(val &gt; root-&gt;val) root-&gt;right = insertIntoBST(root-&gt;right, val);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="450-删除二叉搜索树中的节点httpsleetcodecnproblemsdelete-node-in-a-bst">
  <a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a>
  <a class="heading-link" href="#450-%e5%88%a0%e9%99%a4%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9httpsleetcodecnproblemsdelete-node-in-a-bst">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    TreeNode* deleteNode(TreeNode* root, <span style="">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> <span style="font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(root-&gt;val == key){
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span>(root-&gt;left == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> root-&gt;right;
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span>(root-&gt;right == <span style="font-weight:bold">nullptr</span>) <span style="font-weight:bold">return</span> root-&gt;left;
</span></span><span style="display:flex;"><span>            TreeNode* minNode = getMin(root-&gt;right);
</span></span><span style="display:flex;"><span>            root-&gt;right = deleteNode(root-&gt;right, minNode-&gt;val);
</span></span><span style="display:flex;"><span>            minNode-&gt;left = root-&gt;left;
</span></span><span style="display:flex;"><span>            minNode-&gt;right = root-&gt;right;
</span></span><span style="display:flex;"><span>            root = minNode;
</span></span><span style="display:flex;"><span>        }<span style="font-weight:bold">else</span> if(root-&gt;val &lt; key){
</span></span><span style="display:flex;"><span>            root-&gt;right = deleteNode(root-&gt;right, key);
</span></span><span style="display:flex;"><span>        }<span style="font-weight:bold">else</span>{
</span></span><span style="display:flex;"><span>            root-&gt;left = deleteNode(root-&gt;left, key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeNode* getMin(TreeNode* node){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">while</span>(node-&gt;left != <span style="font-weight:bold">nullptr</span>) node = node-&gt;left;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="96-不同的二叉搜索树httpsleetcodecnproblemsunique-binary-search-trees">
  <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>
  <a class="heading-link" href="#96-%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91httpsleetcodecnproblemsunique-binary-search-trees">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="">int</span> memo[20][20];
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="">int</span> numTrees(<span style="">int</span> n) {
</span></span><span style="display:flex;"><span>        memset(memo, 0, <span style="font-weight:bold">sizeof</span>(memo));
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> count(1, n);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="">int</span> count(<span style="">int</span> lo, <span style="">int</span> hi){
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(hi &lt; lo) <span style="font-weight:bold">return</span> 1;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(memo[lo][hi] != 0) <span style="font-weight:bold">return</span> memo[lo][hi];
</span></span><span style="display:flex;"><span>        <span style="">int</span> res = 0;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">int</span> mid = lo; mid &lt;= hi; mid++){
</span></span><span style="display:flex;"><span>            <span style="">int</span> leftres = count(lo, mid-1);
</span></span><span style="display:flex;"><span>            <span style="">int</span> rightres = count(mid+1, hi);
</span></span><span style="display:flex;"><span>            res += leftres * rightres; <span style="font-style:italic">//每次计算以其中一个为根节点的情况
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        memo[lo][hi] = res;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="95-不同的二叉搜索树-iihttpsleetcodecnproblemsunique-binary-search-trees-ii">
  <a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a>
  <a class="heading-link" href="#95-%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91-iihttpsleetcodecnproblemsunique-binary-search-trees-ii">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="font-weight:bold">class</span> <span style="font-weight:bold">Solution</span> {
</span></span><span style="display:flex;"><span><span style="font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    vector&lt;TreeNode*&gt; generateTrees(<span style="">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> build(1, n);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector&lt;TreeNode*&gt; build(<span style="">int</span> lo, <span style="">int</span> hi){
</span></span><span style="display:flex;"><span>        vector&lt;TreeNode*&gt; res;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span>(hi &lt; lo){
</span></span><span style="display:flex;"><span>            res.push_back(<span style="font-weight:bold">nullptr</span>);
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">int</span> mid = lo; mid &lt;= hi; mid++){
</span></span><span style="display:flex;"><span>            vector&lt;TreeNode*&gt; left = build(lo, mid-1);
</span></span><span style="display:flex;"><span>            vector&lt;TreeNode*&gt; right = build(mid+1, hi);
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">for</span>(<span style="font-weight:bold">auto</span> l: left){
</span></span><span style="display:flex;"><span>                <span style="font-weight:bold">for</span>(<span style="font-weight:bold">auto</span> r: right){
</span></span><span style="display:flex;"><span>                    TreeNode* root = <span style="font-weight:bold">new</span> TreeNode(mid);
</span></span><span style="display:flex;"><span>                    root-&gt;left = l;
</span></span><span style="display:flex;"><span>                    root-&gt;right = r;
</span></span><span style="display:flex;"><span>                    res.push_back(root);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="235-二叉搜索树的最近公共祖先httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree">
  <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a>
  <a class="heading-link" href="#235-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88httpsleetcodecnproblemslowest-common-ancestor-of-a-binary-search-tree">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>...
</span></span></code></pre></div>
      </div>


      <footer>
        


        
        <div id="commento"></div>
<script src="https://cdn.commento.io/js/commento.js"></script>
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2022 -
    
    2023
     游泳小狗 
    ·
    
    技术支持 <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  
  
  <script src="/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js" integrity="sha256-I2BJOV3DaC&#43;ycZZAhylY4S8fJAZ7sJwyeyM&#43;YpDH7aw="></script>
  

  

  

  <script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '//cdn.usefathom.com/tracker.js', 'fathom');
fathom('set', 'siteId', 'ABCDE');
fathom('trackPageview');
</script>


  <script async defer data-domain="example.com" src="https://plausible.io/js/plausible.js"></script>


  <script data-goatcounter="https://code.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>


  
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
        data-cf-beacon='{"token": "token"}'></script>



  <script type="application/javascript">
  var _paq = window._paq = window._paq || [];
   
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://analytics.example.com/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', 'ABCDE']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>


  
<script async src="https://www.googletagmanager.com/gtag/js?id=gid"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'gid');
</script>


  <script type="text/javascript">
    !function(T,l,y){var S=T.location,k="script",D="connectionString",C="ingestionendpoint",I="disableExceptionTracking",E="ai.device.",b="toLowerCase",w="crossOrigin",N="POST",e="appInsightsSDK",t=y.name||"appInsights";(y.name||T[e])&&(T[e]=t);var n=T[t]||function(d){var g=!1,f=!1,m={initialize:!0,queue:[],sv:"5",version:2,config:d};function v(e,t){var n={},a="Browser";return n[E+"id"]=a[b](),n[E+"type"]=a,n["ai.operation.name"]=S&&S.pathname||"_unknown_",n["ai.internal.sdkVersion"]="javascript:snippet_"+(m.sv||m.version),{time:function(){var e=new Date;function t(e){var t=""+e;return 1===t.length&&(t="0"+t),t}return e.getUTCFullYear()+"-"+t(1+e.getUTCMonth())+"-"+t(e.getUTCDate())+"T"+t(e.getUTCHours())+":"+t(e.getUTCMinutes())+":"+t(e.getUTCSeconds())+"."+((e.getUTCMilliseconds()/1e3).toFixed(3)+"").slice(2,5)+"Z"}(),name:"Microsoft.ApplicationInsights."+e.replace(/-/g,"")+"."+t,sampleRate:100,tags:n,data:{baseData:{ver:2}}}}var h=d.url||y.src;if(h){function a(e){var t,n,a,i,r,o,s,c,u,p,l;g=!0,m.queue=[],f||(f=!0,t=h,s=function(){var e={},t=d.connectionString;if(t)for(var n=t.split(";"),a=0;a<n.length;a++){var i=n[a].split("=");2===i.length&&(e[i[0][b]()]=i[1])}if(!e[C]){var r=e.endpointsuffix,o=r?e.location:null;e[C]="https://"+(o?o+".":"")+"dc."+(r||"services.visualstudio.com")}return e}(),c=s[D]||d[D]||"",u=s[C],p=u?u+"/v2/track":d.endpointUrl,(l=[]).push((n="SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details)",a=t,i=p,(o=(r=v(c,"Exception")).data).baseType="ExceptionData",o.baseData.exceptions=[{typeName:"SDKLoadFailed",message:n.replace(/\./g,"-"),hasFullStack:!1,stack:n+"\nSnippet failed to load ["+a+"] -- Telemetry is disabled\nHelp Link: https://go.microsoft.com/fwlink/?linkid=2128109\nHost: "+(S&&S.pathname||"_unknown_")+"\nEndpoint: "+i,parsedStack:[]}],r)),l.push(function(e,t,n,a){var i=v(c,"Message"),r=i.data;r.baseType="MessageData";var o=r.baseData;return o.message='AI (Internal): 99 message:"'+("SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details) ("+n+")").replace(/\"/g,"")+'"',o.properties={endpoint:a},i}(0,0,t,p)),function(e,t){if(JSON){var n=T.fetch;if(n&&!y.useXhr)n(t,{method:N,body:JSON.stringify(e),mode:"cors"});else if(XMLHttpRequest){var a=new XMLHttpRequest;a.open(N,t),a.setRequestHeader("Content-type","application/json"),a.send(JSON.stringify(e))}}}(l,p))}function i(e,t){f||setTimeout(function(){!t&&m.core||a()},500)}var e=function(){var n=l.createElement(k);n.src=h;var e=y[w];return!e&&""!==e||"undefined"==n[w]||(n[w]=e),n.onload=i,n.onerror=a,n.onreadystatechange=function(e,t){"loaded"!==n.readyState&&"complete"!==n.readyState||i(0,t)},n}();y.ld<0?l.getElementsByTagName("head")[0].appendChild(e):setTimeout(function(){l.getElementsByTagName(k)[0].parentNode.appendChild(e)},y.ld||0)}try{m.cookie=l.cookie}catch(p){}function t(e){for(;e.length;)!function(t){m[t]=function(){var e=arguments;g||m.queue.push(function(){m[t].apply(m,e)})}}(e.pop())}var n="track",r="TrackPage",o="TrackEvent";t([n+"Event",n+"PageView",n+"Exception",n+"Trace",n+"DependencyData",n+"Metric",n+"PageViewPerformance","start"+r,"stop"+r,"start"+o,"stop"+o,"addTelemetryInitializer","setAuthenticatedUserContext","clearAuthenticatedUserContext","flush"]),m.SeverityLevel={Verbose:0,Information:1,Warning:2,Error:3,Critical:4};var s=(d.extensionConfig||{}).ApplicationInsightsAnalytics||{};if(!0!==d[I]&&!0!==s[I]){var c="onerror";t(["_"+c]);var u=T[c];T[c]=function(e,t,n,a,i){var r=u&&u(e,t,n,a,i);return!0!==r&&m["_"+c]({message:e,url:t,lineNumber:n,columnNumber:a,error:i}),r},d.autoExceptionInstrumented=!0}return m}(y.cfg);function a(){y.onInit&&y.onInit(n)}(T[t]=n).queue&&0===n.queue.length?(n.queue.push(a),n.trackPageView({})):a()}(window,document,{
    src: "https://js.monitor.azure.com/scripts/b/ai.2.min.js", 
    
    
    
    crossOrigin: "anonymous", 
    
    cfg: { 
        connectionString: "connectionstring"
         
    }});
    </script>    

</body>

</html>
