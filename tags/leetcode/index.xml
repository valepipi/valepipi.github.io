<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on 游泳小狗</title>
    <link>https://valepipi.github.io/tags/leetcode/</link>
    <description>Recent content in LeetCode on 游泳小狗</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 01 Jun 2023 09:56:54 +0800</lastBuildDate><atom:link href="https://valepipi.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>🎰 LeetCode数组题解-差分数组 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-array-sub/</link>
      <pubDate>Thu, 01 Jun 2023 09:56:54 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-array-sub/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
差分数组: 主要适用场景是频繁对原始数组的某个区间的元素进行增减。
差分数组工具类 class Difference{ public: vector&amp;lt;int&amp;gt; diff; Difference(vector&amp;lt;int&amp;gt;&amp;amp; nums){ assert(nums.size() &amp;gt; 0); diff = vector&amp;lt;int&amp;gt;(nums.size()); diff[0] = nums[0]; for(int i = 1; i&amp;lt;nums.size(); i++){ diff[i] = nums[i] - nums[i-1]; } } void increment(int i, int j, int val){ diff[i] += val; if(j+1 &amp;lt; diff.size()) // 注意 diff[j+1] -= val; } vector&amp;lt;int&amp;gt; result(){ vector&amp;lt;int&amp;gt; res(diff.size()); res[0] = diff[0]; for(int i = 1; i&amp;lt; diff.size(); i++) res[i] = res[i-1] + diff[i]; return res; } }; 🎰 &amp;lt;数组-差分数组&amp;gt; 题目列表&amp;hellip;</description>
    </item>
    
    <item>
      <title>🎰 LeetCode数组题解-二分查找 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-array-bisearch/</link>
      <pubDate>Thu, 01 Jun 2023 09:56:54 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-array-bisearch/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
二分查找：搜索左边界、搜索右边界
二分查找框架 //搜索左边界的二分查找 int left_bound(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target){ int left = 0, right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left)/2; if(nums[mid] &amp;lt; target){ left = mid + 1; }else{ right = mid - 1; } } if(left &amp;gt;= nums.size() || nums[left] != target) return -1; return left; } //搜索右边界的二分查找 int right_bound(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target){ int left = 0, right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left)/2; if(nums[mid] &amp;gt; target){ right = mid - 1; }else{ left = mid + 1; } } if(right &amp;lt; 0 || nums[right] !</description>
    </item>
    
    <item>
      <title>🎰 LeetCode数组题解-滑动窗口 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-window/</link>
      <pubDate>Thu, 01 Jun 2023 09:56:54 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-window/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
滑动窗口：寻找最优解，构造窗口[left, right) 滑动哈希：在滑动窗口中快速计算窗口中元素的哈希值, 设计一种哈希编码方式用O(1)优化暴力匹配
滑动窗口void slidingWindow(string s){ unordered_map&amp;lt;char, int&amp;gt; window; int left = 0, right = 0; while(right &amp;lt; s.size()){ char c = s[right]; window.add(c); right++; // 增大窗口 // ... while(left &amp;lt; right &amp;amp;&amp;amp; window need shrink){ char d = s[left]; window.remove(d); left++; // 缩小窗口 } } } 滑动哈希滑动数字：删除高位，添加低位
// 删除高位 8264 -&amp;gt; 264 int number = 8264; int R = 10; //number的进制 int removeVal = 8; //number的最高位数字 int L = 4; //原来 number的位数 number = number - removeVal*pow(R, L-1); // 8264 - 8000 = 264 // 添加低位 8264 -&amp;gt; 38264 int number = 8264; int R = 10; // number的位数 int appendVal = 3; // 添加的数字 number = R*number + appendVal; // 8264*10 + 3= 82643 🎰 &amp;lt;滑动窗口&amp;gt; 题目列表&amp;hellip;</description>
    </item>
    
    <item>
      <title>🎰 LeetCode数组题解-前缀和 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-array-presum/</link>
      <pubDate>Thu, 01 Jun 2023 09:56:54 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-array-presum/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
前缀和：主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。
前缀和框架 class PrefixSum{ private: int* prefix; public: PrefixSum(vector&amp;lt;int&amp;gt;&amp;amp; nums){ prefix = new int[nums.size()+1]; for(int i = 0; i &amp;lt; nums.size(); i++) prefix[i+1] = prefix[i] + nums[i]; } int query(int i, int j){ return prefix[j+1] - prefix[i]; } } 🎰 &amp;lt;数组-前缀和&amp;gt; 题目列表&amp;hellip;
题解303. 区域和检索 - 数组不可变// 简单
暴力法：每次遍历数组求和，时间O(N) 前缀和：时间O(1) 前缀和：主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。
构造前缀和 PreSum[i] = nums[0]~nums[i](tips:PreSum[0]=0，空出) 查询 sumRange[left, right] = PreSum[right+1] - PreSum[left] class NumArray { private: vector&amp;lt;int&amp;gt; PreSum; public: NumArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { PreSum.</description>
    </item>
    
    <item>
      <title>🎰 LeetCode数组题解-双指针 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-array-doubleptr/</link>
      <pubDate>Thu, 01 Jun 2023 09:56:54 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-array-doubleptr/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
🎰 &amp;lt;数组-双指针&amp;gt; 题目列表&amp;hellip;
题解26. 删除有序数组中的重复项//简单
原地修改，双指针
slow记录当前元素，fast在前方试探下一个不同的元素 fast遇到不同的元素时，赋值给slow的下一个位置 (数组有序) 当fast遍历完数组，结束；此时，0-slow是去重后的数组 class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int slow = 0; int fast = 0; if(nums.size() == 0) return 0; while(fast &amp;lt; nums.size()){ if(nums[slow] != nums[fast]){ slow++; nums[slow] = nums[fast]; } fast++; } return slow+1; } }; 27. 移除元素//简单 26. 删除有序数组中的重复项的变体
原地修改，双指针
移除指定的元素
修改nums[slow] = nums[fast]条件即可: nums[fast] != val
class Solution{ public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { int slow = 0; int fast = 0; while(fast &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>🎰 LeetCode数组题解-原地翻转 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-array-inverse/</link>
      <pubDate>Thu, 01 Jun 2023 09:56:54 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-array-inverse/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
原地翻转：组间反转，组内不变 hello world -&amp;gt; word hello；矩阵反转、螺旋矩阵
原地翻转- 一维- 先整个翻转 `hello world -&amp;gt; dlrow olleh`- 再翻转每个组内 `dlrow olleh -&amp;gt; word hello`- 二维（矩阵顺时针旋转）- 整个矩阵转置 (逆时针旋转则是沿着副对角线方向转置)- 翻转每一行内沿主对角线镜像翻转二维矩阵(转置)
swap(matrix[i][j], matrix[j][i])
for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; i; j++) { // swap(matrix[i][j], matrix[j][i]) int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } 沿副对角线镜像翻转二维矩阵</description>
    </item>
    
    <item>
      <title>🎰 LeetCode数组题解 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-array/</link>
      <pubDate>Sat, 13 May 2023 16:38:45 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-array/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
🎰 &amp;lt;数组&amp;gt; 题目列表&amp;hellip;
技巧前缀和：主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。
差分数组: 主要适用场景是频繁对原始数组的某个区间的元素进行增减。
原地翻转：组间反转，组内不变 hello world -&amp;gt; word hello；矩阵反转、螺旋矩阵 滑动窗口：寻找最优解，构造窗口[left, right) 滑动哈希：在滑动窗口中快速计算窗口中元素的哈希值, 设计一种哈希编码方式用O(1)优化暴力匹配 二分搜索
前缀和框架class PrefixSum{ private: int* prefix; public: PrefixSum(vector&amp;lt;int&amp;gt;&amp;amp; nums){ prefix = new int[nums.size()+1]; for(int i = 0; i &amp;lt; nums.size(); i++) prefix[i+1] = prefix[i] + nums[i]; } int query(int i, int j){ return prefix[j+1] - prefix[i]; } } 差分数组工具类class Difference{ public: vector&amp;lt;int&amp;gt; diff; Difference(vector&amp;lt;int&amp;gt;&amp;amp; nums){ assert(nums.size() &amp;gt; 0); diff = vector&amp;lt;int&amp;gt;(nums.</description>
    </item>
    
    <item>
      <title>🔗 LeetCode链表题解 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-linklist-c&#43;&#43;/</link>
      <pubDate>Tue, 09 May 2023 09:45:06 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-linklist-c&#43;&#43;/</guid>
      <description>本文为链表的Leetcode刷题记录。
参考资料: labuladong
🔗 &amp;lt;链表&amp;gt; 题目列表&amp;hellip;
题解单链表节点定义
struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; 21.合并两个有序链表//简单
dummy
class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* dummy = new ListNode(-1); ListNode* p = dummy; ListNode* p1 = list1; ListNode* p2 = list2; while(p1 != nullptr &amp;amp;&amp;amp; p2 !</description>
    </item>
    
    <item>
      <title>🌴 LeetCode二叉树题解 (C&#43;&#43;)</title>
      <link>https://valepipi.github.io/posts/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-c&#43;&#43;/</link>
      <pubDate>Sun, 07 May 2023 14:26:59 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91-c&#43;&#43;/</guid>
      <description>本文为二叉树和二叉搜索树的Leetcode刷题记录。
参考资料: labuladong
🌴 &amp;lt;二叉树&amp;gt; 题目列表力扣题目 知识点 难度 104. 二叉树的最大深度 遍历 简单 543. 二叉树的直径 遍历 简单 144. 二叉树的前序遍历 遍历 简单 226. 翻转二叉树 遍历 简单 114. 二叉树展开为链表 递归 中等 116. 填充每个节点的下一个右侧节点指针 遍历三叉树 中等 105. 从前序与中序遍历序列构造二叉树 递归构造 中等 106. 从中序与后序遍历序列构造二叉树 递归构造 中等 889. 根据前序和后序遍历构造二叉树 递归构造(结果不唯一) 中等 654. 最大二叉树 递归构造 中等 652. 寻找重复的子树 后序遍历 中等 337. 打家劫舍 III 遍历 中等 236. 二叉树的最近公共祖先 递归 中等 222. 完全二叉树的节点个数 递归 中等 297. 二叉树的序列化与反序列化 递归 困难 题解二叉树结点定义</description>
    </item>
    
    <item>
      <title>🐰LeetCode Hot100 题解 (Python)</title>
      <link>https://valepipi.github.io/posts/leetcode/</link>
      <pubDate>Sat, 21 Jan 2023 19:57:59 +0800</pubDate>
      
      <guid>https://valepipi.github.io/posts/leetcode/</guid>
      <description>😃数学问题1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: &amp;#34;&amp;#34;&amp;#34; 1. 暴力查找O(n^2) 2. 利用dict反查O(n) &amp;#34;&amp;#34;&amp;#34; # n = len(nums) # for i in range(n): # for j in range(i + 1, n): # if nums[i] + nums[j] == target: # return [i ,j] # return [] dict = {} for i in range( len(nums) ): if target - nums[i] not in dict: dict[nums[i]] = i #建立反查表 else: return [dict[target-nums[i]], i] 88.</description>
    </item>
    
  </channel>
</rss>
