<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CNN on Ping&#39;s Blog</title>
    <link>https://valepipi.github.io/en/tags/cnn/</link>
    <description>Recent content in CNN on Ping&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 30 Jan 2023 16:06:16 +0800</lastBuildDate><atom:link href="https://valepipi.github.io/en/tags/cnn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ReRAM存算一体加速CNN</title>
      <link>https://valepipi.github.io/en/posts/reram%E5%8A%A0%E9%80%9Fcnn/</link>
      <pubDate>Mon, 30 Jan 2023 16:06:16 +0800</pubDate>
      
      <guid>https://valepipi.github.io/en/posts/reram%E5%8A%A0%E9%80%9Fcnn/</guid>
      <description>ReRAM器件特性ReRAM 是一种无源双端型阻性器件，可储存多个阻态(MLC)。
存储模式VS计算模式：一般的，ReRAM 阵列在进行计算操作时需要将所有的输入端口打开。
优势可作为存储元件，将数据以电阻/电导的形式储存在器件中；
可以依据欧姆定律作为模拟计算元件，实现电导与电压相乘的运算。而 ReRAM交叉阵列结构使得同一列的输出电流能够直接在位线上汇聚，与乘累加运算相匹配，凭借这种原理 ReRAM 阵列可以直接在存储本地实现矩阵-向量乘法运算，突破了传统 CPU 存算分离的架构。
缺点多值存储不稳定：目前 ReRAM 器件工艺还不成熟，多阻态之间的阈值区间间隔不大，导致 ReRAM 作为多阻态器件不稳定，目前已有 的基于 ReRAM 的神经网络研究都是将 ReRAM 当作**单比特器件(SLC)**来使用
写入比读取开销大得多：不同于传统存储器件，ReRAM 的阻 变机制导致其读写操作的延时和能耗严重不均衡，对于 ReRAM 多值器件来说，写 操作所需的时间长、输入电压大，写操作的延时和能耗是读操作的 10 倍以上。
ReRAM加速器与其他模块的关系：
ReRAM加速神经网络的关键问题不能直接支持超大规模卷积神经网络(如，三维神经网络)的高能效运算： 相比于二维卷积神经网络，三维卷积神经网络需要的参数量和训练所需的内存容量呈指数倍增长，而将三维卷积神经网络映射到二维 ReRAM 阵列会使阵列面积大幅增加，从而导致串扰等现象更加严重，影响算法的精度。 包含以下两个关键问题： 如何将 卷积核运算转换为适合 ReRAM 计算结构处理的矩阵-向量乘法运算，并使得该转 换引入尽可能少的额外数据传输代价 如何高能效的将多比特神经网络权重值存储到单比特 ReRAM 器件 CNN中运算的大量数据迁移CNN末端的全连接层：需要读取大量的权重矩阵，并与该层的输入向量进行矩阵-向量乘法运算。(得到的输出向量既可直接作为识别结果输出， 又可以通过非线性神经元函数作为下一个全连接层的输入向量。)
CNN中的卷积核运算(占比95%以上)：由于卷积核的每一个元素都是训练得到的神经网络参数，因此卷积核运算中需要反复从存储数据中读取卷积核参数，并与输入特征图进行卷积运算。
CNN卷积核运算映射到二维ReRAM卷积核运算：将两个三维矩阵中的对应元素进行乘加运算；如果将两个三维矩阵按照相同顺序进行完全地展开，那么卷积运算就可以看作为 向量的内积运算。
基于矩阵-向量乘法运算的原理，有两种可能实现的卷积运算映射方法：
特征图数据作为电导值写入到 ReRAM 阵列单元中，卷积核作为 ReRAM 阵列端口的输入电压向量：
可将相同卷积核对应的不同滑窗位置的特征图数据映射到多个 ReRAM 列中，这样可以在同一时钟周期下计算出不同滑窗位置上的卷积结果，而在不同周期下能够计算出多个卷积核的卷积结果。
优点：对于单个特征图的卷积运算有较大的并行度
缺点：(1)进行不同特征图的运算时需要对ReRAM 阵列进行反复擦写，并且写开销远大于读开销; (2)使得神经网络的后一层运算需要等上一层的运算结果写入到 ReRAM 阵列中才能进行运算。</description>
    </item>
    
    <item>
      <title>神经网络基础</title>
      <link>https://valepipi.github.io/en/posts/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 30 Jan 2023 14:45:42 +0800</pubDate>
      
      <guid>https://valepipi.github.io/en/posts/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
      <description>神经网络基本概念神经网络分为两个阶段的运算：训练、推理
训练——过程视角正向传播：目的是使用当前未训练好的网络对训练样本进行推理；过程和推理过程完全一致，包含大量的矩阵-向量乘法运算 反向传播：目的是根据正向传播获得的计算误差，依次计算并存储各层的中间变量以及参数的梯度，包含大量反向的矩阵-向量乘法运算 权重更新：在正向或反向传播的过程中都会进行权重更新，需要计算各权重矩阵的梯度大小，得到权重的更新值，实现模型的更新 推理——结构视角全连接层
卷积层
目的：利用卷积运算的局部特性提取图像的局部特征并逐层抽象 与全连接层的区别：卷积层可以用较少的模型参数实 现对大规模图像的特征提取 特征图(feature map)：在卷积层间传输的特征数据；输入特征图——&amp;gt;卷积核——&amp;gt;输出特征图 卷积核(Convolution Kernel)：卷积核运算是卷积层中的主要运算，涉及大量的数据计算和数据传输。卷积核运算是将两个三维矩阵中的对应元素进行乘法运算，再将乘得的结果进行累加计算。 S为卷积核的行/列的数量，I 为输入特征图的通道数，即一个卷积核的大小为 S×S×I；
假设通道数=1时，一个卷积核在特征图上扫过的面积就是输出结果的size：一个卷积核扫过特征图上的一个区域就得到一个值(size=1*1)，把所有区域的值按照行列拼接起来就是结果(size=扫过的面积)
其他：级联在两层卷积运算中间的辅助运算，如非线性神经元函数(ReLU/Sigmoid)、池化(Pooling)等 非线性神经元函数
目的：提供非线性分类能力，广泛用于传统全连接神经网络、卷积神经网络等各类神经网络算法中 在CNN中，通常级联在卷积核运算后 池化函数
目的：对特征图进行空间压缩,降低特征图的维度 做法：把特征图相邻范围内的所有元素 用一个值替代，从而在保持局部特征的同时，降低卷积神经网络的计算量和参数量 与卷积核运算的区别：池化函数尽管使用与卷积核相同的滑窗形式，在全特征图中进行运算，但是*步长（Stride）*运算形式会令同一个特征图元素不会被包含至多个池化区域内。 形式：平均池化（Mean Pooling）、最大池化（Max Pooling） 相比于平均池化，最大池化更容易保留特征图中最鲜明的特征信息</description>
    </item>
    
  </channel>
</rss>
